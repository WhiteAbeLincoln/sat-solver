#+OPTIONS: toc:nil num:nil
#+LATEX_CLASS_OPTIONS: [10pt,AMS Euler]
#+LATEX_HEADER: \input{../preamble.tex} \usepackage{algpseudocode,algorithm}
#+AUTHOR: Abraham White
#+TITLE: Serial SAT Solver
* Description
  The Boolean Satisfiability Problem (SAT) is an NP-complete decision problem,
  where the goal is to find whether there is an assignment of values to boolean variables
  in a propositional formula such that the formula evaluates to true. For example,
  determining whether \[ a \land \neg a \] can be true for some value of $a$ is
  an SAT problem.
  
  Most SAT solvers take their input as a propositional logic formula in conjunctive normal form (CNF),
  involving variables and the operators /negation/ ($\neg$), /disjunction/ ($\lor$), and /conjunction/ ($\land$). A
  propositional logic formula in CNF is the conjunction of a set of clauses. A /clause/ is a disjunction
  of literals, and a /literal/ is a boolean variable $A$ which can be either positive ($A$), or negative ($\neg A$).
  
  An /interpretation/ is a mapping from a CNF formula to the set of truth values $\{\top,\bot\}$ through assignment
  of truth values to the literals in the formul. SAT solvers use /partial interpretations/, where only some of the
  literals in the formula are assigned truth values. These variables are replaced with their truth values in
  the formula and the formula is then simplified using the rules of propositional logic.
  
  The Boolean Satisfiability Problem is the question of whether there exists an interpretation for a formula such
  that the formula evaluates to $\top$ under this interpretation.
  
  There are two types of SAT solvers: complete, and stochastic. Complete solvers attempt to
  either find a solution, or show that no solutions exist. Stochastic solvers cannot prove
  that a formula is unsolvable, but can find solutions for specific kinds of problems very
  quickly. We are attempting to build a complete SAT solver.

  Many modern complete SAT solvers are based on a branch and backtracking algorithm called
  Davis-Putnam-Logemann-Loveland (DPLL), a refinement of the earlier Davis-Putnam algorithm and 
  introduced in 1962 by Martin Davis, George Logemann, and Donald W. Loveland. Many of these solvers
  add additional heuristics on top of the DPLL algorithm, which can increase efficiency, but adds significant
  complexity to the implementation.
  
  A more recent aproach is the conflict-driven clause learning algorithm (CDCL), inspired by the original DPLL
  algorithm. 
  
* Implementation
  #+begin_export latex
\begin{algorithm}
\caption{The recursive DPLL algorithm}
\label{alg:rec_dpll}
\begin{algorithmic}[1]
\Function{dpll}{$F$ : Formula}
\If {$F$ is empty}
  \State \Return SAT
\ElsIf {$F$ contains an empty clause}
  \State \Return UNSAT
\ElsIf {$F$ contains a pure literal $l$} \label{alg:rec_dpll_litelim}
  \State \Return \Call{dpll}{$F[l \to \top]$}
\ElsIf {$F$ contains a unit clause $[l]$} \label{alg:rec_dpll_unitprop}
  \State \Return \Call{dpll}{$F[l \to \top]$}
\Else
  \State let $l$ be a literal in $F$
  \If {\Call{dpll}{$F[l \to \top]$} = SAT}
    \State \Return SAT
  \Else
    \State \Return \Call{dpll}{$F[l \to \bot]$}
  \EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
  #+end_export
  
  The basic DPLL algorithm can be defined recursively as in Algorithm\nbsp{}ref:alg:rec_dpll.
  In the algorithm, $F[l \to \top]$ denotes the formula obtained by replacing the literal $l$ with $\top$ and
  $\neg l$ with $\bot$ in $F$. A literal is pure if it occurs in $F$ but its opposite does not. A clause is unit
  if it contains only one literal. The formula is consistent if for every literal in the formula there doesn't
  also exist the opposite. Unfortunately, this recursive algorithm becomes unusable with larger formulae.
  
  The DPLL algorithm consists of two key steps:
  1. *Literal Elimination*: If some literal is only seen in pure form, we can immediately determine the
     truth value for that literal. For instance, if the literal is in the form $A$, we know that $A$ must be
     $\top$, and if the literal is in the form $\neg A$, $A$ must be $\bot$. This step occurs on line
     ref:alg:rec_dpll_litelim of the recursive algorithm .
  2. *Unit Propogation*: If there is a unit clause then we can immediately assign a truth value in the same
     way we do for literal elimination. This is done on line ref:alg:rec_dpll_unitprop of the recursive
     algorithm.
     
  For both the DPLL and CDCL algorithms, we will take our input in conjunctive normal form. For implementation,
  we represent literals as integers, with a negative integer being the logical negation of the corresponding
  positive literal. Clauses are represented by a list of these integer literals, and a formula is represented
  by a list of clauses. We exclude 0 from the possible literals.
  For instance, we can encode the formula $(A \lor \neg B \lor \neg C) \land (\neg D \lor E \lor F)$ with
  #+begin_src c++
std::vector<std::vector<int>> formula = {{1, -2, -3}, {-4, 5, 6}};
  #+end_src
  
  Now we begin the implementation of the recursive DPLL algorithm in C++. Since C++ doesn't
  support tail-recursive calls, we have to transform the recursive algorithm into a mostly
  iterative one.
  
  First we set up a data structure to keep track of the assignment of truth values, and another to keep
  track of the clauses a literal appears in. We also do some work to recognize pure literals, which
  will be eliminated in a later step.
  
  We define an adjacency list to associate literals with clauses that reference them using
  an unordered map. The =LitData= struct is used in the undordered map to keep track of the
  clauses where a literal occurs positively ($x$), or negatively ($\neg x$). The =ClauseData= struct
  keeps track of the number of its literals assigned true or false which tells us whether the clause
  is satisfied, unsatisfied, or unit.
  #+name: formula
  #+begin_src c++
struct Formula {
  struct ClauseData {
    int n_t = 0;
    int n_f = 0;
    std::vector<int> literals;
    int orig_len;
    bool sat() { return n_t >= 1; }
    bool unsat() { return n_f == orig_len; }
    bool unit() { return n_t == 0 && n_f == (orig_len - 1); }
  };
  struct LitData {
    int assn = -1;
    std::vector<int> pos_clauses;
    std::vector<int> neg_clauses;
    bool pure() {
      return assn == -1 && (pos_clauses.size() == 0 || neg_clauses.size() == 0);
    }
  };
  std::vector<ClauseData> clauses;
  std::unordered_map<int, LitData> literals;
  int remaining;
  void add_literal(int l, int cpos) {
    auto s = sign(l);
    auto pos = l*s;
    auto it = this->literals.find(pos);
    LitData data;
    if (it != this->literals.end()) data = it->second;
    if (s == 1) {
      data.pos_clauses.push_back(cpos);
    } else {
      data.neg_clauses.push_back(cpos);
    }
    this->literals.insert_or_assign(pos, data);
  }
  Formula(std::vector<std::vector<int>> formula)
        : remaining(formula.size()) {
    for (auto c : formula) {
      ClauseData cd;
      cd.literals = c;
      cd.orig_len = c.size();
      auto cpos = this->clauses.size();
      this->clauses.push_back(cd);
      for (auto l : c) this->add_literal(l, cpos);
    }
  }
};
  #+end_src
  
  We need to actually implement the recursive DPLL algorithm.
  The algorithm itself is simple, but the helper functions will be more
  complicated.
  #+name: dpll
  #+begin_src c++
std::tuple<bool, std::vector<int>, std::vector<int>> ret_val(Formula& f, bool sat) {
  if (!sat) return {false, {}, {}};
  std::vector<int> assnt;
  std::vector<int> assnf;
  for (auto l : f.literals) {
    if (l.second.assn == 1)
      assnt.push_back(l.first);
    if (l.second.assn == 0)
      assnf.push_back(l.first);
  }
  return {true, assnt, assnf};
}
std::tuple<bool, std::vector<int>, std::vector<int>> dpll(Formula& f, BranchRule rule) {
  for (auto& l : f.literals) {
    if (l.second.pure()) {
      pure_literal_assign(f, l.first, l.second);
    }
  }
  for (long unsigned int i = 0; i < f.clauses.size(); ++i) {
    auto c = f.clauses[i];
    if (c.sat()) continue;
    if (c.literals.size() == 0) {
      if (VERBOSE) std::cerr << "VERBOSE: Empty Clause - UNSAT" << std::endl;
      return ret_val(f, false);
    }
    if (c.unit()) {
      if (VERBOSE) std::cerr << "VERBOSE: Unit Propogate " << i << " ";
      unit_propogate(f, c);
    }
  }
  if (f.remaining == 0) {
    if (VERBOSE) std::cerr << "VERBOSE: No Remaining - SAT" << std::endl;
    return ret_val(f, true);
  }
  auto l = get_branching_variable(f, rule);
  if (VERBOSE) std::cerr << "VERBOSE: Branching on " << l << std::endl;
  Formula oldf(f);
  set_var(f, l);
  auto [res, ts, fs] = dpll(f, rule);
  if (res) return {res, ts, fs};
  if (VERBOSE) std::cerr << "VERBOSE: Backtracking" << std::endl;
  f = oldf;
  if (VERBOSE) std::cerr << "VERBOSE: Branching on " << -l << std::endl;
  set_var(f, -l);
  return dpll(f, rule);
}
  #+end_src
  The implementation goes as follows:
  First we handle the pure literal step, which removes whole clauses from
  consideration by assigning truth values. We use the =pure_literal_assign=
  function to set a value for the literals. First we determine the sign
  of the literal by the clauses it is contained in, since the map removes
  that information from the key. We then make a truth assignment, and 
  update the associated clauses. We remove satisfied clauses from the
  adjacency lists of other literals, since any other truth assignments
  don't matter and the clause doesn't have to be considered any more.
  #+name: pure_literal
  #+begin_src c++
void remove_satisfied(Formula& f, int d) {
  auto& clause = f.clauses[d];
  clause.n_t++;
  f.remaining--;
  if (VERBOSE) {
    std::cerr << "VERBOSE: Removing satisfied clause " << d << ", "
              << f.remaining << " Remaining" << std::endl;
  }
  auto lits = clause.literals;
  for (auto l : lits) {
    auto s = sign(l);
    auto& lit = f.literals[l*s];
    if (s == 1) {
      auto& p = lit.pos_clauses;
      p.erase(std::remove(p.begin(), p.end(), d), p.end());
    } else {
      auto& n = lit.neg_clauses;
      n.erase(std::remove(n.begin(), n.end(), d), n.end());
    }
  }
  clause.literals.clear();
}
void pure_literal_assign(Formula& f, int l, Formula::LitData& data) {
  auto pos_size = data.pos_clauses.size();
  auto s = (pos_size == 0) ? -1 : 1;
  if (VERBOSE) std::cerr << "VERBOSE: Pure Literal - " << s*l << std::endl;
  auto lclauses = (s == 1) ? data.pos_clauses : data.neg_clauses;
  data.assn = (pos_size != 0) ? 1 : 0;
  if (VERBOSE) {
    std::cerr << "VERBOSE: Assigned " << l << " as "
              << (data.assn ? "TRUE" : "FALSE") << std::endl;
  }
  for (auto cidx : lclauses) remove_satisfied(f, cidx);
}
  #+end_src

  The next loop in the dpll implementation helps with unit propogation.
  We skip over clauses that have already been satisfied, terminate when we
  have a clause that is empty, i.e. there was a conflicting literal asignment,
  and then propogate when the clause is unit. We use the =unit_propogate= function to
  make a truth asignment for the unit literal. Internally, all =unit_propogate=
  does is change the formula by setting a truth assignment for the unit literal.
  #+name: unit_propogate
  #+begin_src c++
void set_var(Formula& f, int l) {
  auto s = sign(l);
  auto pos = l*s;
  auto& lit = f.literals[pos];
  if (lit.assn != -1) throw std::runtime_error("literal already assigned");
  lit.assn = (s == 1) ? 1 : 0;
  if (VERBOSE) {
    std::cerr << "VERBOSE: Assigned " << l*s << " as "
              << (lit.assn ? "TRUE" : "FALSE") << std::endl;
  }
  auto sat_c = (lit.assn == 1) ? lit.pos_clauses : lit.neg_clauses;
  auto& unsat_c = (lit.assn == 0) ? lit.pos_clauses : lit.neg_clauses;
  for (auto cidx : sat_c) remove_satisfied(f, cidx);
  for (auto cidx : unsat_c) {
    auto& clause = f.clauses[cidx];
    clause.n_f++;
    if (VERBOSE) {
      std::cerr << "VERBOSE: Removing " << ((lit.assn == 0) ? pos : -pos)
                << " from clause " << cidx << std::endl;
    }
    clause.literals.erase(std::remove(clause.literals.begin(),
                                      clause.literals.end(),
                                      (lit.assn == 0) ? pos : -pos),
                          clause.literals.end());
    if (clause.literals.size() == 0) f.remaining--;
  }
  unsat_c.clear();
}
void unit_propogate(Formula& f, Formula::ClauseData clause) {
  auto l = clause.literals[0];
  if (VERBOSE) std::cerr << "[" << l << "]" << std::endl;
  set_var(f, l);
}
  #+end_src

  Back in the dpll implmentation, check if there are any remaining unsatisfied
  clauses, returning true if we have satisfied all. Finally, we pick a
  variable using a heuristic and branch, backtracking if the first choice of
  assignment doesn't work. For this we use the =get_branching_variable= function
  to determine a branching variable using a heuristic, and the =set_var=
  function to handle changing the formula.
  
** Branching Rules
  Branching rules are used for choosing which literal to set to true during
  the last step of the DPLL algorithm. These are typically based on heuristics,
  and various strategies have been formalized in papers over the years.
  Ouyang cite:ouyang created a paradigm which associates with each literal $u$ a weight $w(F, u)$,
  and then chooses a function $\Phi$ of two variables:
  + Find a variable $x$ that maximizes $\Phi(w(F,x), w(F, \neg x))$; choose $x$ if
    $w(F, x) \geq w(F,\neg x)$, choosing $\neg x$ otherwise. Ties in the case that more
    than one variable maximizes $\Phi$ are broken by some rule.
   
  Usually $w(F,u)$ is defined in terms of the number of clauses of length $k$ in $F$ that contain the
  literal $u$, denoted $d_k(F, u)$. A selection of some branching rules follow:
*** Dynamic Largest Individual Sum (DLIS)
    \begin{align*}
    w(F,u) &= \sum_k d_k(F,u) \\
    \Phi(x,y) &= \max\{x,y\}
    \end{align*}
    
    Notice that $\sum_k d_k(F,u)$ is simply the number of clauses in which $u$ is present,
    since $k$ can range from 1 to $\infty$.
*** Dynamic Largest Combined Sum (DLCS)
    \begin{align*}
    w(F,u) &= \sum_k d_k(F,u) \\
    \Phi(x,y) &= x + y
    \end{align*}
*** Jeroslow-Wang (JW) rule
    \begin{align*}
    w(F,u) &= \sum_k 2^{-k} d_k(F,u) \\
    \Phi(x,y) &= \max\{x,y\}
    \end{align*}
*** 2-Sided Jeroslow-Wang rule
    \begin{align*}
    w(F,u) &= \sum_k 2^{-k} d_k(F,u) \\
    \Phi(x,y) &= x + y
    \end{align*}
*** DSJ rule
    \begin{align*}
    w(F,u) &= 4d_2(F,u) + 2d_3(F,u) + \sum_{k\geq 4} d_k(F,u) \\
    \Phi(x,y) &= (x+1)(y+1)
    \end{align*}
    
 #+name: get_branching
 #+begin_src c++
auto dlis(Formula f, int l) {
  int wp = nclauses(f, -1, l);
  int wn = nclauses(f, -1, -l);
  return std::make_tuple(wp, wn, std::max(wp, wn));
}
auto dlcs(Formula f, int l) {
  int wp = nclauses(f, -1, l);
  int wn = nclauses(f, -1, -l);
  return std::make_tuple(wp, wn, wp + wn);
}
auto jw(Formula f, int l) {
  auto largest_k = get_largest_k(f);
  int wp = 0;
  int wn = 0;
  for (int k = 1; k <= largest_k; ++k) {
    wp += std::pow(2, -k) * nclauses(f, k, l);
    wn += std::pow(2, -k) * nclauses(f, k, -l);
  }
  return std::make_tuple(wp, wn, std::max(wp, wn));
}
auto jw2(Formula f, int l) {
  auto largest_k = get_largest_k(f);
  int wp = 0;
  int wn = 0;
  for (int k = 1; k <= largest_k; ++k) {
    wp += std::pow(2, -k) * nclauses(f, k, l);
    wn += std::pow(2, -k) * nclauses(f, k, -l);
  }
  return std::make_tuple(wp, wn, wp + wn);
}
auto dsj(Formula f, int l) {
  auto largest_k = get_largest_k(f);
  int wp = 4*nclauses(f, 2, l) + 2*nclauses(f, 3, l);
  int wn = 4*nclauses(f, 2, -l) + 2*nclauses(f, 3, -l);
  for (int k = 4; k <= largest_k; ++k) {
    wp += nclauses(f, k, l);
    wn += nclauses(f, k, -l);
  }
  return std::make_tuple(wp, wn, (wp+1)*(wn+1));
}
int get_branching_variable(Formula f, BranchRule rule) {
  switch (rule) {
    case BranchRule::dlis:
      return apply_rule(f, &dlis);
    case BranchRule::dlcs:
      return apply_rule(f, &dlcs);
    case BranchRule::jw:
      return apply_rule(f, &jw);
    case BranchRule::jw2:
      return apply_rule(f, &jw2);
    case BranchRule::dsj:
      return apply_rule(f, &dsj);
  }
  throw std::runtime_error("get_branching_variable didn't handle all cases");
}
 #+end_src
  
* Appendix
** Helper Code
*** sign
    Apparently the standard =copysign= is slow
    #+name: sign
    #+begin_src c++
int sign(int x) {
  return ( (x > 0) ? 1
         : (x < 0) ? -1
         : 0);
}
    #+end_src
*** Read Input
    Reads input from stdin as the DIMACS cnf format.
    #+name: read_input
    #+begin_src c++
auto read_input() {
  bool cnf_mode = false;
  std::vector<std::vector<int>> f;
  std::vector<int> clause;
  for (std::string l; std::getline(std::cin, l);) {
    if (l.empty()) continue;
    std::stringstream ss(l);
    std::string word;
    ss >> word;
    if (word == "c") continue;
    if (word == "p") {
      ss >> word;
      if (word != "cnf") throw std::invalid_argument("Data must be in cnf format, got " + word);
      cnf_mode = true;
      continue;
    }
    do {
      if (word == "%") return f;
      int v = std::stoi(word);
      if (v == 0) {
        f.push_back(clause);
        clause.clear();
      } else {
        clause.push_back(v);
      }
    } while (ss >> word);
    if (!cnf_mode) { 
      f.push_back(clause);
      clause.clear();
    }
  }
  
  return f;
}
    #+end_src
*** Branching Enum
    Used to specify the choice of branching rule
    #+name: branch_enum_def
    #+begin_src c
enum class BranchRule { dlis, dlcs, jw, jw2, dsj };
    #+end_src
*** Branching Helpers
    Included here to save space in the main section.
    #+name: branch_helper
    #+begin_src c
int nclauses(Formula f, int k, int u) {
  auto s = sign(u);
  auto& lit = f.literals[u*s];
  auto cs = (s == 1) ? lit.pos_clauses : lit.neg_clauses;
  int counter = 0;
  if (k == -1) return cs.size();
  for (auto c : cs) {
    if (f.clauses[c].literals.size() == (unsigned int)k) counter++;
  }
  return counter;
}
int get_largest_k(Formula f) {
  return std::max_element(f.clauses.begin(), f.clauses.end(),
                  [](auto a, auto b) {
                    return a.literals.size() < b.literals.size();
                  })->literals.size();
}
int apply_rule(Formula f, std::function<std::tuple<int,int,int>(Formula, int)> rule) {
  int maximum = 0;
  int curr = 0;
  for (auto l : f.literals) {
    if (l.second.assn != -1) continue;
    auto [wp, wn, phi] = rule(f, l.first);
    if (phi >= maximum) {
      curr = wp >= wn ? l.first : -l.first;
      maximum = phi;
    }
  }
  if (curr == 0) throw std::runtime_error("branching heuristic failed");
  return curr;
}
    #+end_src
*** Full Source
    See =serial_dpll.cpp=
    #+begin_src c :noweb yes :tangle serial_dpll.cpp :exports none :comments noweb
#include <iostream>
#include <functional>
#include <algorithm>
#include <vector>
#include <stack>
#include <tuple>
#include <sstream>
#include <unistd.h>
#include <string>
#include <cmath>

bool VERBOSE = false;

<<sign>>
<<read_input>>
<<branch_enum_def>>
<<formula>>
<<pure_literal>>
<<unit_propogate>>
<<branch_helper>>
<<get_branching>>
<<dpll>>

void print_graph(Formula formula) {
  std::cerr << "VERBOSE: Literal graph is" << std::endl;
  std::cerr << "VERBOSE: LGRAPH digraph literal {" << std::endl;
  for (long unsigned int i = 0; i < formula.clauses.size(); ++i) {
    std::cerr << "VERBOSE: LGRAPH " << i << " [shape=box];" << std::endl;
  }
  for (auto l : formula.literals) {
    for (auto c : l.second.pos_clauses) {
      std::cerr << "VERBOSE: LGRAPH " << l.first << " -> " << c << ";" << std::endl;
    }
    for (auto c : l.second.neg_clauses) {
      std::cerr << "VERBOSE: LGRAPH " << -l.first << " -> " << c << ";" << std::endl;
    }
  }
  std::cerr << "VERBOSE: LGRAPH }" << std::endl;
}

void help(std::string name) {
  std::cout << "DPLL" << std::endl;
  std::cout << "Usage:\t" << name << " [OPTIONS]" << std::endl;
  std::cout << "\t-h\tShow this screen" << std::endl;
  std::cout << "\t-v\tVerbose Output" << std::endl;
  std::cout << "\t-r <RULE>\tSet branch rule (one of dlis|dlcs|jw|jw2|dsj)" << std::endl;
}

int main(int argc, char** argv) {
  int opt;
  std::string input = "";
  BranchRule rule = BranchRule::dlis;
  while ((opt = getopt(argc, argv, "hvr:")) != -1) {
    switch (opt) {
      case 'h': {
        help(argv[0]);
        return 0;
      }
      case 'v': {
        VERBOSE = true;
        break;
      }
      case 'r': {
        std::string r(optarg);
        if (r == "dlis") {
          rule = BranchRule::dlis;
        } else if (r == "dlcs") {
          rule = BranchRule::dlcs;
        } else if (r == "jw") {
          rule = BranchRule::jw;
        } else if (r == "jw2") {
          rule = BranchRule::jw2;
        } else if (r == "dsj") {
          rule = BranchRule::dsj;
        } else {
          help(argv[0]);
          return EXIT_FAILURE;
        }
        break;
      }
      default:
        help(argv[0]);
        return EXIT_FAILURE;
    }
  }
  
  Formula formula(read_input());
  if (VERBOSE) print_graph(formula);
  auto [sat, assnt, assnf] = dpll(formula, rule);
  std::cout << "Formula is: " << (sat ? "SAT" : "UNSAT") << std::endl;
  if (!sat) return 20;
  std::cout << "Variables assigned TRUE:" << std::endl;
  for (auto l : assnt) std::cout << l << " ";
  std::cout << std::endl;
  std::cout << "Variables assigned FALSE:" << std::endl;
  for (auto l : assnf) std::cout << l << " ";
  std::cout << std::endl;
  return 10;
}
    #+end_src
    
[[bibliographystyle:unsrt]]
[[bibliography:refs.bib]]
* COMMENT Local Variables
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-latex-export-to-pdf) (org-babel-tangle)) nil t)
  # End:
  
